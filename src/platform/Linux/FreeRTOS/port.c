/*
 * FreeRTOS Port implementation for Linux using POSIX Threads
 *
 * - Each RTOS tasks runs in a own thread
 * - Threads are suspended / resumed by async signals
 * - Those signal are generated by the scheduler thread
 * - vPortYield triggers the scheduler thread
 * - The systick is generated by a POSIX timer
 * - and is handled synchronized within the main thread
 * - While systick is handled all threads running RTOS tasks are suspended
 *
 * Debugging:
 * - Content of pxTasks might be a good staring point. It holds the state of the
 *   RTOS tasks and the corresponding thread id.
 *
 *
 * Copyright (C) 2019 Andreas Innerlohninger <innerand@nxa.at>
 *
 * This code is subject to the terms and conditions defined at the MIT Licence
 * which are specified at the end of this file and/or a separate license file.
 */

/* Includes ------------------------------------------------------------------*/
#include <errno.h>
#include <pthread.h>
#include <semaphore.h>
#include <signal.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <time.h>
#include <unistd.h>

#include "FreeRTOS.h"
#include "queue.h"
#include "task.h"

/* Private Definitions -------------------------------------------------------*/
#define ERREXIT(s)                                                             \
  printf("Error: %s (%s[%d], %s)", (s), __FUNCTION__, __LINE__, __FILE__);     \
  exit(1)
// #define LOG(msg,...) printf("[%ld]", prvGetNsTs()); printf(msg,
// ##__VA_ARGS__); printf("\n");
#define LOG(msg, ...)

/** Internal task credentials */
typedef struct {
  bool xUsed;              /* Task created */
  sig_atomic_t xSuspended; /* Task suspended */
  int xId;                 /* Internal task ID */
  pthread_t xThreadId;     /* ID of the POSIX thread running the task */
  TaskHandle_t pxHandle;   /* RTOS task handle */
  TaskFunction_t pxCode;   /* RTOS task function */
  void *pvParameters;      /* RTOS function parameters */
} portTask_t;

/** Port task command definition */
typedef enum {
  EndScheduler = 0,
} portCmd_t;

/** Port task command data structure */
typedef struct {
  portCmd_t cmd;
} portTaskCmd_t;

/* Private Function declarations ---------------------------------------------*/

static void prvInit(void);
static void prvStartSchedulerThread(void);
static bool prvStartSystickTimer(void);
static void prvStopSystickTimer(void);
static void *prvSchedulerThread(void *arg);
static void *prvTask(void *arg);
static unsigned long prvGetNsTs(void);
static int prvGetIdFromHandle(TaskHandle_t handle);
static int prvGetIdFromThreadId(pthread_t id);
static void prvSchedulerEndCleanup(void);
static void prvSuspendTaskBlocking(int task_id);
static void prvResumeTaskBlocking(int task_id);
static void prvResumeSchedulerBlocking(void);
static void prvPortTask(void *pvParamters);
static void prvEndScheduler(void);
bool prvIsRtosContext(pthread_t thread_id);

static void prvSigResumeHandler(int sig, siginfo_t *si, void *uc);
static void prvSigSuspendHandler(int sig, siginfo_t *si, void *uc);
static void prvSigtimerHandler(int sig, siginfo_t *si, void *uc);

/* Private Variables ---------------------------------------------------------*/

static volatile portTask_t pxTasks[configPORT_MAX_TASKS];
static int xLastCreatedTaskId = configPORT_MAX_TASKS;

/* Context switch IDs */
static volatile int xTaskToResume = configPORT_MAX_TASKS;
static volatile int xTaskToSuspend = configPORT_MAX_TASKS;

/* System Threads */
static pthread_t xMainThreadId;
static pthread_t xSchedulerThreadId;
static int xIdleTaskId;

/* Semaphores */
static sem_t xSchedulerSem;    /* Scheduler available  */
static sem_t xResumeSem;       /* (Any) Task has resumed */
static sem_t xSuspendSem;      /* (Any) Task is suspended */
static sem_t xCriticalSem;     /* Critical section */
static sem_t xPauseSem;        /* Scheduler Pause */
static sem_t xEndSchedulerSem; /* Blocks Scheduler End */

/* Mutexes */
static pthread_mutex_t xSchedulerMutex = PTHREAD_MUTEX_INITIALIZER;
static pthread_cond_t xSchedulerCond = PTHREAD_COND_INITIALIZER;
static pthread_mutex_t xSchedulerStartedMutex = PTHREAD_MUTEX_INITIALIZER;
static pthread_cond_t xSchedulerStartedCond = PTHREAD_COND_INITIALIZER;

/* Flags */
static volatile sig_atomic_t xEndScheduler = 0;
static volatile sig_atomic_t xSystick = 0;
static volatile sig_atomic_t xTimerTickPending = 0;
static volatile bool xYieldPending = false;
static volatile bool xResumeScheduler = false;
static volatile bool xSchedulerStarted = false;
static volatile bool xPaused = false;
static bool xInitialized = false;
static bool xTasksEnded = false;

/* A variable is used to keep track of the critical section nesting. */
static UBaseType_t uxCriticalNesting = 0xaaaaaaaa;

static timer_t xSystickTimerId;

/* Signal mask used by the prvSigResumeHandler */
static sigset_t xSuspendMask;

static QueueHandle_t xPortTaskCmdQueue;

/* Public Functions ----------------------------------------------------------*/

/* Early Initialization
 *
 * Must be called from the main thread before any RTOS functions are called
 */
int vPortEarlyInit(void) {
  sigset_t blockset;
  sigemptyset(&blockset);
  sigaddset(&blockset, portSIGTIMER);
  sigaddset(&blockset, portSIGSUSPEND);
  sigaddset(&blockset, portSIGRESUME);
  sigaddset(&blockset, portSIGSCHEDULE);

  pthread_sigmask(SIG_BLOCK, &blockset, NULL);

  return 0;
}

#if (configPORT_USE_REINIT != 0)
/* Reinitialize static variables of the FreeRTOS Kernel
 *
 * Static variables of the FreeRTOS kernel are declared with the macro
 * PRIVILEGED_DATA. This macro can be used by this port to put them into a
 * dedicated memory section which is set to 0 by this function.
 * The result should be a quite clean state of the kernel.
 */
void vPortReinitFreeRtos(void) {
  extern char __free_rtos_start__;
  extern char __free_rtos_stop__;
  char *start = &__free_rtos_start__;
  char *end = &__free_rtos_stop__;
  size_t bytes = ((intptr_t)end - (intptr_t)start);

  memset(start, 0, bytes);

  //    printf("Memory section 'free_rtos':\n"
  //           "start: %p, end: %p, size: %d\n", start, end, bytes);
}
#endif

/*
 * Stop all tasks and disable 'interrupts' (stop systick handling)
 */
void vPortPause(void) {
  /* Block until the scheduler has been started */
  pthread_mutex_lock(&xSchedulerStartedMutex);
  while (xSchedulerStarted == false) {
    pthread_cond_wait(&xSchedulerStartedCond, &xSchedulerStartedMutex);
  }
  pthread_mutex_unlock(&xSchedulerStartedMutex);

  while (sem_wait(&xPauseSem))
    ;

  /* No pause during critical section */
  while (sem_wait(&xCriticalSem))
    ;

  /* No Pause while context switch ongoing */
  while (sem_wait(&xSchedulerSem))
    ;

  xPaused = true;

  /* End running task */
  if (pxTasks[xTaskToResume].xUsed) {
    prvSuspendTaskBlocking(xTaskToResume);
  }

  /* All tasks are stopped by now */
  sem_post(&xSchedulerSem);
  sem_post(&xCriticalSem);
}
/*-----------------------------------------------------------*/

/*
 * Resume task execution stopped by vPortPause()
 */
void vPortResume(void) {
  sem_post(&xPauseSem);

  if (xPaused && !xEndScheduler) {
    xPaused = false;
    prvResumeTaskBlocking(xTaskToResume);
  }
}
/*-----------------------------------------------------------*/

void vPortEnterCritical(void) {
  if (uxCriticalNesting == 0) {
    while (sem_wait(&xCriticalSem)) {
      /*
       * The Thread may be suspended while waiting for the semaphore.
       * If a other thread has meanwhile entered critical section,
       * therefore obtained the semaphore, it's not longer necessary to
       * wait for it.
       */
      if (uxCriticalNesting != 0) {
        break;
      }
    }
  }

  uxCriticalNesting++;
}
/*-----------------------------------------------------------*/

void vPortExitCritical(void) {
  bool post_critical_sem = false;

  if (uxCriticalNesting == 1) {
    post_critical_sem = true;
  }

  if (uxCriticalNesting) {
    uxCriticalNesting--;
  }

  if (post_critical_sem) {
    sem_post(&xCriticalSem);
  }

  if (uxCriticalNesting == 0 && !xPaused) {
    if (xTimerTickPending) {
      pthread_kill(xMainThreadId, portSIGTIMER);
      xTimerTickPending = 0;
    }

    if (xYieldPending) {
      xYieldPending = false;
      vPortYield();
    }
  }
}
/*-----------------------------------------------------------*/

/*
 * See header file for description.
 */
StackType_t *pxPortInitialiseStack(StackType_t *pxTopOfStack,
                                   TaskFunction_t pxCode, void *pvParameters) {
  /* Initialize task credentials */
  if (!xInitialized) {
    prvInit();
  }

  vPortEnterCritical();

  /* Find next free task index */
  size_t idx = configPORT_MAX_TASKS;
  for (size_t i = 0; i < configPORT_MAX_TASKS; i++) {
    if (pxTasks[i].xUsed == false) {
      idx = i;
      break;
    }
  }

  if (idx >= configPORT_MAX_TASKS) {
    ERREXIT("All threads occupied. Increase configPORT_MAX_TASKS");
  }

  /* Initialize task credentials */
  pxTasks[idx].xUsed = true;
  pxTasks[idx].xSuspended = true;
  pxTasks[idx].xId = idx;
  pxTasks[idx].pxHandle = NULL;
  pxTasks[idx].pxCode = pxCode;
  pxTasks[idx].pvParameters = pvParameters;
  xLastCreatedTaskId = idx;

  /* Temporarily block all signals (SIGMASK is inherited to threads) */
  sigset_t block, restore;
  sigfillset(&block);

  if (pthread_sigmask(SIG_BLOCK, &block, &restore) != 0) {
    ERREXIT("pthread_sigmask block all");
  }

  /* Create Thread */
  pthread_create((pthread_t *)&pxTasks[idx].xThreadId, NULL, prvTask,
                 (void *)&pxTasks[idx]);

  /* Restore previous signal mask */
  if (pthread_sigmask(SIG_SETMASK, &restore, NULL) != 0) {
    ERREXIT("pthread_sigmask restore");
  }

  /*  Wait for created task to suspend */
  while (sem_wait(&xSuspendSem))
    ;
  vPortExitCritical();

  return (StackType_t *)pxTopOfStack;
}
/*-----------------------------------------------------------*/

/*
 * Stores the RTOS task handle of the latest created task
 */
void vPortSetupTCB(void *pvTaskHandle) {
  TaskHandle_t handle = (TaskHandle_t)pvTaskHandle;

  if (xLastCreatedTaskId < configPORT_MAX_TASKS) {
    pxTasks[xLastCreatedTaskId].pxHandle = handle;
    xLastCreatedTaskId = configPORT_MAX_TASKS;
  } else {
    ERREXIT("Received task handle while id was invalid");
  }
}
/*-----------------------------------------------------------*/

/*
 * Task delete callback. End task, cleanup task credentials
 */
void vPortCleanUpTCB(void *pvTaskHandle) {
  int id = prvGetIdFromHandle((TaskHandle_t)pvTaskHandle);

  /* Check if the task handle was valid */
  if (id >= configPORT_MAX_TASKS) {
    ERREXIT("Cleanup: Received invalid task handle");
  }

  /* ------------------------------- */
  vPortEnterCritical();
  /* ------------------------------- */

  /*
   * If vTaskEndScheduler is called outside of RTOS tasks the idle task ends
   * itself.
   */
  if (pxTasks[id].xThreadId == pthread_self()) {
    if (id == xIdleTaskId) {
      /* Note: Technically we leak memory here as the idle tasks stack is
       *       freed after the call to vPortCleanUpTCB.
       *       However, as the heap gets reinitialized anyway we don't
       *       care.
       */
      pthread_exit(NULL);
    } else {
      ERREXIT("Cleanup: Tried to cancel active task");
    }
  }

  /* End thread running the task to delete */
  pthread_cancel(pxTasks[id].xThreadId);

  /*
   * Wait for thread to terminate, except the idle thread which is joined at
   * the main thread
   */
  if (id != xIdleTaskId) {
    if (pthread_join(pxTasks[id].xThreadId, NULL) != 0) {
      ERREXIT("Cleanup: Unable to join");
    }
  }

  pxTasks[id].xUsed = false;

  /* ------------------------------- */
  vPortExitCritical();
  /* ------------------------------- */
}
/*-----------------------------------------------------------*/

/*
 * See header file for description.
 */
BaseType_t xPortStartScheduler(void) {
  xMainThreadId = pthread_self();

  /* Get idle task id
   *
   * The idle task is the first task created by vTaskStartScheduler
   */
  int task_id_max = -1;
  for (int task = 1; task < configPORT_MAX_TASKS; task++) {
    if (!pxTasks[task].xUsed) {
      task_id_max = task - 1;
      break;
    }
  }

  if (task_id_max < 0) {
    ERREXIT("Unable to find max task id");
  }

#if (configUSE_TIMERS == 1)
  task_id_max--;
#endif

  xIdleTaskId = task_id_max;

  /* Create internal service task */
  xPortTaskCmdQueue = xQueueCreate(4, sizeof(portTaskCmd_t));

  if (xPortTaskCmdQueue == NULL) {
    ERREXIT("Unable to create port task command queue");
  }

  TaskHandle_t xPortTaskHdl;
  BaseType_t xRet =
      xTaskCreate(prvPortTask, "PortTask", configMINIMAL_STACK_SIZE,
                  (void *)NULL, 1, &xPortTaskHdl);

  if (xRet != pdPASS) {
    ERREXIT("Unable to create port task");
  }
  /* --------------------------- */

  /* Start scheduler, systick and enable interrupts */
  prvStartSchedulerThread();
  prvStartSystickTimer();
  uxCriticalNesting = 0;

  /* Resume first task */
  xTaskToResume = prvGetIdFromHandle(xTaskGetCurrentTaskHandle());

  /* Check if thread exists and is enabled */
  if ((xTaskToResume >= configPORT_MAX_TASKS) ||
      (pxTasks[xTaskToResume].xUsed == false)) {
    ERREXIT("Tried to resume invalid thread");
  }

  prvResumeTaskBlocking(xTaskToResume);

  /* Signal scheduler started */
  pthread_mutex_lock(&xSchedulerStartedMutex);
  xSchedulerStarted = true;
  pthread_mutex_unlock(&xSchedulerStartedMutex);
  pthread_cond_signal(&xSchedulerStartedCond);

  /* Handle Systicks */
  while (!xEndScheduler) {
    /* Process system tick */
    if (xSystick && !xPaused) {
      vPortPause();

      /* Increment tick, check if context switch is required */
      xSystick = 0;
      if (xTaskIncrementTick() == pdTRUE || xYieldPending) {
        vPortYield();
        xPaused = false;
        xYieldPending = false;
        sem_post(&xPauseSem);
      } else {
        vPortResume();
      }
    }

    /* Safe point to end the Scheduler */
    sem_post(&xEndSchedulerSem);

    pause();

    while (sem_trywait(&xEndSchedulerSem) != 0) {
      if (errno == EINTR) {
        continue;
      }
      if (xEndScheduler != 0) {
        break;
      }
      ERREXIT("EndSchedulerSem deadlock");
    }

  } /* Main thread loop */

  prvSchedulerEndCleanup();

  return pdTRUE;
}
/*-----------------------------------------------------------*/

/*
 *  End scheduler public interface
 */
void vPortEndScheduler(void) {
  BaseType_t higherPrioWoken;
  portTaskCmd_t cmd;
  cmd.cmd = EndScheduler;

  if (prvIsRtosContext(pthread_self())) {
    xQueueSend(xPortTaskCmdQueue, &cmd, portMAX_DELAY);
  } else {
    /* Check if the scheduler has been paused already */
    bool paused = xPaused;

    if (!paused) {
      vPortPause();
    }
    xQueueSendFromISR(xPortTaskCmdQueue, &cmd, &higherPrioWoken);
    // TODO: Implement yield from ISR
    // portYIELD_FROM_ISR(higherPrioWoken);
    if (!paused) {
      vPortResume();
    }
  }
}
/*-----------------------------------------------------------*/

/*
 *  Task switch
 */
void vPortYield(void) {
  /* Post is done at scheduler thread */
  while (sem_wait(&xSchedulerSem))
    ;

  prvResumeSchedulerBlocking();

  /* Suspend this task */
  if (pthread_self() != xMainThreadId) {
    pause();
  }

  return;
}
/*-----------------------------------------------------------*/

/*
 *  Delayed context switch
 */
void vPortYieldWithinAPI(void) {
  if (uxCriticalNesting) {
    xYieldPending = true;
  } else {
    vPortYield();
  }
}
/*-----------------------------------------------------------*/

/* Private Functions ---------------------------------------------------------*/

/*
 * Cleanup after scheduler has ended
 *
 * Run at main thread after vTaskEndScheduler has been called
 */
static void prvSchedulerEndCleanup(void) {
  struct timespec xDelayTs = {.tv_sec = 0, .tv_nsec = 100000};

  /* Wait for all tasks to be set as deleted */
  while (!xTasksEnded) {
    pause();
  }

  /* Resume the idle task which should finally delete the task called
   * `vTaskEndScheduler`
   */
  prvResumeTaskBlocking(xIdleTaskId);

  /* Wait for all tasks to be deleted and removed (except idle) */
  bool tasks_deleted = false;
  while (!tasks_deleted) {
    nanosleep(&xDelayTs, NULL);

    int count = 0;
    for (int task = 0; task < configPORT_MAX_TASKS; task++) {
      if (pxTasks[task].xUsed) {
        count++;
      };
    }

    if (count <= 1) {
      tasks_deleted = true;
    }
  }

  /* Finally delete the idle task */
  vTaskDelete(pxTasks[xIdleTaskId].pxHandle);

  /* Wait for the idle task to exit */
  if (pthread_join(pxTasks[xIdleTaskId].xThreadId, NULL) != 0) {
    ERREXIT("Cleanup: Unable to join");
  }

  /* End scheduler thread */
  pthread_cancel(xSchedulerThreadId);
  if (pthread_join(xSchedulerThreadId, NULL) != 0) {
    ERREXIT("Cleanup: Unable to join");
  }

  /* Stop the systick timer */
  prvStopSystickTimer();

  sem_destroy(&xSchedulerSem);
  sem_destroy(&xResumeSem);
  sem_destroy(&xSuspendSem);
  sem_destroy(&xCriticalSem);
  sem_destroy(&xPauseSem);
  sem_destroy(&xEndSchedulerSem);

  xInitialized = false;

  /* Reinitialize memory management */
  vPortInitialiseBlocks();
}
/*-----------------------------------------------------------*/

/*
 * Initialize global variables, semaphores  and register signal handlers
 */
static void prvInit(void) {
  /* Initialize global variables */
  /* --------------------------- */
  memset((void *)&pxTasks, 0, sizeof(pxTasks));
  xEndScheduler = false;
  xLastCreatedTaskId = configPORT_MAX_TASKS;
  xTaskToResume = configPORT_MAX_TASKS;
  xTaskToSuspend = configPORT_MAX_TASKS;
  xTasksEnded = false;

  xMainThreadId = 0;
  xSchedulerThreadId = 0;

  xSystick = 0;
  xTimerTickPending = 0;
  uxCriticalNesting = 0xaaaaaaaa;

  pthread_mutex_lock(&xSchedulerStartedMutex);
  xSchedulerStarted = false;
  pthread_mutex_unlock(&xSchedulerStartedMutex);

  /* Initialize semaphores */
  /* --------------------- */
  if (sem_init(&xSchedulerSem, 0, 1) != 0) {
    ERREXIT("sem init");
  }

  if (sem_init(&xResumeSem, 0, 0) != 0) {
    ERREXIT("sem init");
  }

  if (sem_init(&xSuspendSem, 0, 0) != 0) {
    ERREXIT("sem init");
  }

  if (sem_init(&xCriticalSem, 0, 1) != 0) {
    ERREXIT("sem init");
  }

  if (sem_init(&xPauseSem, 0, 1) != 0) {
    ERREXIT("sem init");
  }

  if (sem_init(&xEndSchedulerSem, 0, 0) != 0) {
    ERREXIT("sem init");
  }

  /* Setup suspend mask */
  /* ------------------ */
  sigfillset(&xSuspendMask);
  sigdelset(&xSuspendMask, portSIGRESUME);

  /* Register Signal Handlers */
  /* ------------------------ */
  struct sigaction sa;

  /* Register (empty) Handler for portSIGRESUME */
  sigemptyset(&sa.sa_mask);
  sa.sa_flags = SA_RESTART | SA_SIGINFO;
  sa.sa_sigaction = prvSigResumeHandler;

  if (sigaction(portSIGRESUME, &sa, NULL) == -1) {
    ERREXIT("portSIGRESUME handler");
  }

  /* Register Handler for portSIGSUSPEND */
  sigemptyset(&sa.sa_mask);
  sa.sa_flags = SA_RESTART | SA_SIGINFO;
  sa.sa_sigaction = prvSigSuspendHandler;

  if (sigaction(portSIGSUSPEND, &sa, NULL) == -1) {
    ERREXIT("portSIGSUSPEND handler");
  }

  /* Establish handler for timer signal */
  sigemptyset(&sa.sa_mask);
  sa.sa_flags = SA_RESTART | SA_SIGINFO;
  sa.sa_sigaction = prvSigtimerHandler;

  if (sigaction(portSIGTIMER, &sa, NULL) == -1) {
    ERREXIT("sigaction");
  }

  xInitialized = true;
}
/*-----------------------------------------------------------*/

/*
 * portSIGRESUME Handler
 */
static void prvSigResumeHandler(int sig, siginfo_t *si, void *uc) {
  /* nothing to do here */
  (void)sig;
  (void)si;
  (void)uc;
}
/*-----------------------------------------------------------*/

/*
 * portSIGSUSPEND Handler
 */
static void prvSigSuspendHandler(int sig, siginfo_t *si, void *uc) {
  pthread_t thread_id = pthread_self();
  int id = prvGetIdFromThreadId(thread_id);

  if (id >= configPORT_MAX_TASKS) {
    ERREXIT("Suspend handler invalid id");
  }

  pxTasks[id].xSuspended = true;
  sem_post(&xSuspendSem);

  /* Suspend the thread until portSIGRESUME is received */
  sigsuspend(&xSuspendMask);

  pxTasks[id].xSuspended = false;
  sem_post(&xResumeSem);

  /* Compiler warnings */
  (void)sig;
  (void)si;
  (void)uc;
}
/*-----------------------------------------------------------*/

/*
 * portSIGTIMER handler
 */
static void prvSigtimerHandler(int sig, siginfo_t *si, void *uc) {
  /* Pend tick if timer is disabled */
  if (uxCriticalNesting || xPaused) {
    xTimerTickPending = 1;
  } else {
    xSystick = 1;
  }

  /* Compiler warnings */
  (void)sig;
  (void)si;
  (void)uc;
}
/*-----------------------------------------------------------*/

/*
 * Starts the Scheduler
 */
static void prvStartSchedulerThread(void) {
  pthread_create(&xSchedulerThreadId, NULL, prvSchedulerThread, NULL);
}
/*-----------------------------------------------------------*/

/*
 * Scheduler suspends/resumes RTOS tasks
 */
static void *prvSchedulerThread(void *arg) {
  /* Set Signal Mask */
  sigset_t maskset;
  sigfillset(&maskset);

  if (pthread_sigmask(SIG_SETMASK, &maskset, NULL) != 0) {
    ERREXIT("pthread_sigmask taskset");
  }

  while (1) {
    /* Wait for a Yield */
    pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);

    pthread_mutex_lock(&xSchedulerMutex);
    while (xResumeScheduler != true) {
      pthread_cond_wait(&xSchedulerCond, &xSchedulerMutex);
    }
    xResumeScheduler = false;
    pthread_mutex_unlock(&xSchedulerMutex);

    pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);

    /* Check if the scheduler should exit */
    if (xEndScheduler) {
      break;
    }

    /* Get id of currently running task */
    xTaskToSuspend = prvGetIdFromHandle(xTaskGetCurrentTaskHandle());

    /* Check if that task exists and is enabled */
    if (xTaskToSuspend >= configPORT_MAX_TASKS ||
        pxTasks[xTaskToSuspend].xUsed == false) {
      ERREXIT("Tried to suspend invalid thread");
    }

    vTaskSwitchContext();

    /* Get id of task to run after actual task switch */
    xTaskToResume = prvGetIdFromHandle(xTaskGetCurrentTaskHandle());

    /* Check if task exists and is enabled */
    if (xTaskToResume >= configPORT_MAX_TASKS ||
        pxTasks[xTaskToResume].xUsed == false) {
      ERREXIT("Tried to resume invalid thread");
    }

    /* Perform context switch */
    if (!pxTasks[xTaskToSuspend].xSuspended) {
      /* Suspend thread */
      prvSuspendTaskBlocking(xTaskToSuspend);
    }

    /* Resume thread */
    prvResumeTaskBlocking(xTaskToResume);

    /* Unlock scheduler */
    sem_post(&xSchedulerSem);
  }

  pthread_exit(NULL);

  /* Compiler warning */
  (void)arg;
}
/*-----------------------------------------------------------*/

/*
 * Thread function running RTOS Tasks
 */
static void *prvTask(void *arg) {
  portTask_t *id = (portTask_t *)arg;

  /* Set Signal Mask */
  sigset_t taskset;
  sigfillset(&taskset);
  sigdelset(&taskset, portSIGSUSPEND);
  sigdelset(&taskset, SIGINT);

  if (pthread_sigmask(SIG_SETMASK, &taskset, NULL) != 0) {
    ERREXIT("pthread_sigmask taskset");
  }

  /* Suspend thread */
  pthread_kill(id->xThreadId, portSIGSUSPEND);

  /* First resume, check if initialization was done */
  if (id->pxHandle == NULL) {
    ERREXIT("RTOS Task misses task handle");
  }

  /* RTOS Task function (shouldn't return, but might) */
  /* ------------------------------------------------ */
  id->pxCode(id->pvParameters);

  /* Thread termination */
  /* ------------------ */
  LOG("[WARN] RTOS task %d returned", id->xId);

#if (INCLUDE_vTaskDelete == 1)
  /* Task will be removed by the idle task */
  vTaskDelete(NULL);
  pthread_kill(id->xThreadId, portSIGSUSPEND);
#else
  ERREXIT("RTOS Task returned");
#endif

  pthread_exit(NULL);
}
/*-----------------------------------------------------------*/

/*
 * Initialize and start systick timer
 */
static bool prvStartSystickTimer(void) {
  struct sigevent sev;
  struct itimerspec its;
  long long freq_nanosecs;

  /* Unblock portSIGTIMER */
  sigset_t timer_set;
  sigemptyset(&timer_set);
  sigaddset(&timer_set, portSIGTIMER);
  sigaddset(&timer_set, SIGINT);

  if (pthread_sigmask(SIG_UNBLOCK, &timer_set, NULL) != 0) {
    ERREXIT("pthread_sigmask timer");
  }

  /* Create the timer */
  memset(&sev, 0, sizeof(struct sigevent));
  sev.sigev_notify = SIGEV_SIGNAL;
  sev.sigev_signo = portSIGTIMER;
  sev.sigev_value.sival_ptr = &xSystickTimerId;
  if (timer_create(CLOCK_MONOTONIC, &sev, &xSystickTimerId) == -1) {
    ERREXIT("timer_create");
  }

  /* Convert frequency to cycle timer */
  freq_nanosecs = (uint32_t)1e9 / configTICK_RATE_HZ;
  memset(&its, 0, sizeof(struct itimerspec));

  its.it_interval.tv_sec = freq_nanosecs / (uint32_t)1e9;
  its.it_interval.tv_nsec = freq_nanosecs % (uint32_t)1e9;
  its.it_value.tv_sec = its.it_interval.tv_sec;
  its.it_value.tv_nsec = its.it_interval.tv_nsec;

  /* Start the timer */
  if (timer_settime(xSystickTimerId, 0, &its, NULL) == -1) {
    ERREXIT("timer_settime");
  }

  return true;
}
/*-----------------------------------------------------------*/

/*
 * Stop systick timer
 */
static void prvStopSystickTimer(void) {
  if (timer_delete(xSystickTimerId) != 0) {
    ERREXIT("Unable to stop timer");
  }
}
/*-----------------------------------------------------------*/

/* Helper Functions */
/* -------------------------------------------------------------------------- */

/*
 * Get internal task id from RTOS task handle
 */
static int prvGetIdFromHandle(TaskHandle_t handle) {
  int idx = configPORT_MAX_TASKS;

  for (int i = 0; i < configPORT_MAX_TASKS; i++) {
    if (pxTasks[i].pxHandle == handle) {
      idx = i;
      break;
    }
  }

  return idx;
}
/*-----------------------------------------------------------*/

/*
 *  Get internal task id from pthread id
 */
static int prvGetIdFromThreadId(pthread_t id) {
  int idx = configPORT_MAX_TASKS;

  for (int i = 0; i < configPORT_MAX_TASKS; i++) {
    if (pxTasks[i].xThreadId == id) {
      idx = i;
      break;
    }
  }

  return idx;
}
/*-----------------------------------------------------------*/

/*
 * Get nanosecond timestamp (process clock)
 */
__attribute__((unused)) static unsigned long prvGetNsTs(void) {
  struct timespec ts;
  clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &ts);

  return ts.tv_nsec;
}
/*-----------------------------------------------------------*/

/* Send portSIGRESUME to task and block until it is resumed */
static void prvResumeTaskBlocking(int task_id) {
  pthread_kill(pxTasks[task_id].xThreadId, portSIGRESUME);
  while (sem_wait(&xResumeSem))
    ;

  /* There can only be one task */
  int semval;
  sem_getvalue(&xResumeSem, &semval);
  if (semval) {
    ERREXIT("Resumed multiple tasks");
  }
}
/*-----------------------------------------------------------*/

/* Send portSIGSUSPEND to task and block until it is suspended */
static void prvSuspendTaskBlocking(int task_id) {
  struct timespec ts;

  if (pthread_kill(pxTasks[task_id].xThreadId, portSIGSUSPEND) != 0) {
    ERREXIT("pthread_kill portSIGSUSPEND");
  }

  if (clock_gettime(CLOCK_REALTIME, &ts) != 0) {
    ERREXIT("clock_gettime");
  }
  ts.tv_sec += 2;

  // FIXME: In rare cases xSuspendSem is not available. Debugging shows that
  //        the task has actually suspended and should have posted the
  //        semaphore. A timeout was added to avoid the deadlock.
  while (sem_timedwait(&xSuspendSem, &ts)) {
    if (errno == ETIMEDOUT) {
      ERREXIT("xSuspendSem timed out");
    }
  }
}
/*-----------------------------------------------------------*/

/*
 * Resume the scheduler thread
 */
static void prvResumeSchedulerBlocking(void) {
  sigset_t blockset, restore_set;

  /* Delay portSIGSUSPEND to ensure cancellation is enabled before the task is
   * suspended  */
  sigemptyset(&blockset);
  sigaddset(&blockset, portSIGSUSPEND);
  pthread_sigmask(SIG_BLOCK, &blockset, &restore_set);

  pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);

  /* Resume Scheduler Task */
  pthread_mutex_lock(&xSchedulerMutex);
  xResumeScheduler = true;
  pthread_mutex_unlock(&xSchedulerMutex);
  pthread_cond_signal(&xSchedulerCond);

  pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);
  pthread_sigmask(SIG_SETMASK, &restore_set, NULL);
}
/*-----------------------------------------------------------*/

/*
 * Port Task
 *
 * This task is use to allow safely execution of non-*FromISR functions called
 * from outside of RTOS context.
 */
static void prvPortTask(void *pvParameters) {
  portTaskCmd_t cmd;

  for (;;) {
    /* Wait for new commands */
    xQueueReceive(xPortTaskCmdQueue, &cmd, portMAX_DELAY);

    switch (cmd.cmd) {
    case EndScheduler:
      vQueueDelete(xPortTaskCmdQueue);
      prvEndScheduler();
      break;

    default:
      break;
    }
  }

  (void)pvParameters;
}
/*-----------------------------------------------------------*/

/*
 * Implementation of End Scheduler
 *
 * FIXME: If the task calling prvEndScheduler is of a higher priority as the
 *        tasks created afterwards starting the scheduler fails.
 *        The last aktive task seen by the kernel should be the idle task (with
 *        priority 0).
 */
static void prvEndScheduler(void) {
#if (INCLUDE_vTaskDelete == 1)
  /* End scheduler, exit main thread loop */
  while (sem_wait(&xEndSchedulerSem))
    ;
  xEndScheduler = true;

  while (sem_wait(&xPauseSem))
    ;

  /* Avoid task switch by timer interrupt */
  vPortEnterCritical();

  /* Set Scheduler ended */
  pthread_mutex_lock(&xSchedulerStartedMutex);
  xSchedulerStarted = false;
  pthread_mutex_unlock(&xSchedulerStartedMutex);

  /* Delete every task except idle task which may be required for cleanup */
  for (int task = 0; task < configPORT_MAX_TASKS; task++) {
    if (pxTasks[task].xUsed && task != xIdleTaskId) {
      vTaskDelete(pxTasks[task].pxHandle);
    }
  }

  xTasksEnded = true;

  /* End Scheduler Task */
  prvResumeSchedulerBlocking();

  /* If called within RTOS Task, exit this thread */
  if (prvIsRtosContext(pthread_self())) {
    pthread_exit(NULL);
  }

#else
  ERREXIT("End Scheduler requires vTaskDelete");
#endif
}
/*-----------------------------------------------------------*/

/*
 * Tests if the `thread_id` is running a RTOS task
 */
bool prvIsRtosContext(pthread_t thread_id) {
  for (int i = 0; i < configPORT_MAX_TASKS; i++) {
    if (pxTasks[i].xThreadId == thread_id) {
      return true;
    }
  }

  return false;
}
/*-----------------------------------------------------------*/

/* License notice ----------------------------------------------------------- */

/*
 * MIT License
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */
